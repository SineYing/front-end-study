# 简单题

## 一、请说出下列最终的执行结果，并解释为什么

```js
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[6]()
```

答：10。是因为在退出循环时，迭代变量保存的是导致循环退出的值10，在之后执行a中的函数时，所有的i都是同一个变量，因而输出的都是同一个最终值。

## 二、请说出下列最终的执行结果，并解释为什么

```js
var tmp = 123
if (true) {
    console.log(tmp)
    let tmp
}
```

答：会产生“ReferenceError”。因为首先let声明的范围是块级作用域，let声明的变量不会在作用域中被提升，在let执行瞬间被称为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出ReferenceError。

## 三、结合ES6新语法，用最简单的方式找出数组的最小值

```js
var arr = [12, 34, 32, 89, 4]
```

答：

```js
var arr = [12, 34, 32, 89, 4]
let min = arr.reduce((pre, item, arr) => {
    return pre - item ? item : pre
})
console.log(min)
```

## 四、请详细说明var，let，const三种声明变量的方式之间的具体差别

答：

- var、let、const都是用来声明变量；
- var在ECMAScript所有版本中都可以使用，而const和let只能在ECMAScript6及更新版本中使用；
- var的声明范围是函数作用域，let和const的声明范围是块级作用域；
- 在函数内定义变量时，省略var操作符，可以创建一个全局变量（严格模式下会报ReferenceError）。var在全局作用域中声明的变量会成为window对象的属性，const和let不可以；
- var存在变量提升。而let存在”暂时性死区“，没声明就使用会报ReferenceError。const声明时必须同时初始化变量；
- 反复多次使用var声明同一个变量也没问题，let和const不允许重复声明；
- const声明的限制只适用于它指向的变量的引用；
- 在for循环中var定义的迭代变量会渗透到循环体外部；
  
  ```js
  for(var i=0; i<5;i++){

  }
  console.log(i)
  //5
  ```

  而使用let声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量，每个函数体引用的都是不同的变量实例。

## 五、请说出下列代码最终输出的结果，并解释为什么

```js
var a = 10
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
```

答：fn()里面的this指向的是obj，setTimeout里面的箭头函数是没有this的，因此箭头函数中的this指向的是离它最近的作用域中的this即fn()里的this就是obj

## 六、简述Symbol类型的用途

答：Symbol是ECMAScript6新增的数据类型，是原始值，且它的实例是唯一不可变的，是用来确保对象属性使用唯一标识符，不会发生属性冲突的危险。

## 七、说说什么是浅拷贝，什么是深拷贝?

答：深拷贝和浅拷贝主要是针对引用类型来说的。把引用类型从一个变量赋值给另一个变量时，其实只是把变量的存储地址进行了拷贝，操作完成后两个变量指向的是同一个堆内存，因此一个对象发生变化会体现在另一个对象上，这就是浅拷贝。
而深拷贝就是在拷贝的过程中会开辟一个新的堆内存。

## 八、请简述TypeScript 与 JavaScript之间的关系

答：TypeScript是JavaScript的超集，提供了类型系统和对Es6的支持，TypeScript可以编译成纯JavaScript

## 九、请谈谈你所认为的TypeScript 优缺点

答：
优点

- 增强代码的可读性和可维护性，在编译时可发现大部分错误；
- 有一定的包容性，js可以直接改为ts，不定义类型可以自动推断类型
- 有较好的生态圈

缺点

- 有一定的学习成本，需要理解接口、泛型、枚举类型等

## 十、描述引用计数的工作原理和优缺点

答：引用计数算法就是设置引用数，判断当前引用数是否为0，当引用关系改变时修改引用计数，引用计数为0时立即回收
优点：发现垃圾会立即回收；会最大程度的减少程序的暂停
缺点：无法回收循环引用的对象；因为要时刻监视引用计数，所以时间开销会比较大

## 十一、描述标记整理算法的工作流程

答：主要分为标记、整理、清除三个阶段；
标记：遍历并标记所有活动对象（及可达对象），通过递归方式去查找子节点及子子节点
整理：移动对象位置，让回收空间在地址上产生连续
清除：遍历所有对象清除没有标记的对象，释放空间，并去掉之前的标记让GC下次可以正常工作

## 十二、描述V8中新生代存储区垃圾回收的流程

答：新生代回收过程采用复制算法和标记整理，新生代将空间分成两个等大的From使用空间和To空闲空间，当From空间使用到一定程度后就会触发GC操作，对活动对象进行标记整理，使位置空间变的连续，以保证不会产生碎片空间，整理完成后From空间的活动对象拷贝到To空间（拷贝过程中如果发现活动对象所使用的空间也出现在老生代，那么次对象会被移动至老生代，此现象称为晋升；如果拷贝后发现To空间的使用率达到25%，那么活动对象也会被移动至老生代），From空间进行释放。

## 十三、描述增量标记算法在何时使用及工作原理

答：当新生代对象向老生代移动的时候，且这个时间点上老生代的存储空间又不足以接收新生代移动过来的对象，这样就会出发老生代的标记整理及增量标记进行效率优化。
因为垃圾回收会阻塞我们程序的运行，所以增量标记就是将一整个垃圾回收的过程拆分成多个部分去完成回收，取代之前一口气完成一整个垃圾回收的操作，主要是实现程序与垃圾回收交替进行。
因为V8引擎使用非增量标记处理最大1.5G垃圾的时间也不会超过1s，所以垃圾增量标记回收时的阻塞时间会更小得多，非常有效的提升了用户体验。
